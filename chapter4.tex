%===================================== CHAP 4 =================================

\chapter{Method}
\section{Sensors, Hardware and Processing Pipeline}
The physical sensor setup used in the data collection is illustrated in figure \ref{fig:sensor_setup}. A HP zbook 15 running Ubuntu 16.04 with ROS was used as a data collection platform.
\begin{figure}[H]
    \centering
    \includegraphics[width=.8\linewidth]{fig/sensor_setup.png}
    \caption{Sensor setup with physical connections.}
    \label{fig:sensor_setup}
\end{figure}
The camera used to gather image data is a commercial off-the-shelf action camera by Muvi, named Veho K2 Sport. The reasoning for using such a camera was the affordable price, relatively high resolution, and a wide angle of view. A serious drawback with such a camera for computer vision applications, however, is the fact that it only sends images as a steady stream over its HDMI interface, with little options for the user to control the capture of individual frames. Moreover, HDMI is not \todo{Kilde p√• at hdmi suger for real time CV} \\
\vspace{2mm}\\
\noindent The specifications of the computer used in the data gathering is listed in table \ref{tab:comp_specs_laptop}.
\begin{tabular}[H]{|c|c|}
\label{tab:comp_specs_laptop}
\centering
\hline
Model & HP zbook 15\\
CPU & Intel Core i7-4800MQ 8$\times$2.7 GHz \\
Memory & 8 GB RAM \\
Graphics & lala \\
Storage & 250 GB Solid State HDD \\
Operating System & Linux Ubuntu 16.04 LTS (Xenial)\\
\hline
\end{tabular}
Overview of the sensor setup, hardware used, and signal flow through the system.
\section{Faster R-CNN}
Introduce the framework of Faster R-CNN
\subsection{Training and validation data}
Describe the datasets used in training and validation (Espen Tangstads work basically)
\subsection{Implementation Aspects}
Steps needed to run the Matlab implementation from https://github.com/ShaoqingRen/faster\_rcnn. Compiling Caffe with cuda for GTX1070, the link between caffe and Matlab (mex).
\section{ROS Implementation}
In order to capture, organize, timestamp and save the collected data, the open-source robotics framework of ROS was used. ROS, which is an abbreviation for Robot Operating System, is not, as the name might imply, a operating system, but a framework running on top of a traditional OS. The framework of ROS is based on several philosophical aspects \cite{programming_ros}:
\begin{itemize}
    \item \textit{Peer to peer}: A ROS system consists of several small programs (called nodes) connected to each other, continuously exchanging messages. Messages travel directly from one node to another.
    \item \textit{Tools-based}: Complex ROS systems can be created from many small, generic programs. ROS does not have a integrated development and runtime environment, and tasks such as (but not limited to) navigating the source code tree, visualizing the system interconnections, generating documentation, and logging data are performed by separate programs.
    \item \textit{Multilingual}: ROS software modules can be written in any language for which a \textit{client library} has been written. Client libraries exist for C++, Python, LISP, Java, JavaScript, MATLAB, Ruby, Haskell, R, and others. This provides flexibility for the programmer, in that he or she can choose the language they are most familiar with, or is best suited for the task, when creating new functionality. ROS achieves this multilinguality by enforcing a convention for serializing messages being passed between nodes.
    \item \textit{Thin}: ROS conventions encourage developers to create standalone libraries and then wrap those libraries so that they can send and receive messages to and from other ROS modules. This allows reuse of software outside ROS, and simplifies automated testing using continuous integration tools.
    \item \textit{Free and open source}: The core of ROS is released under the BSD license \cite{BSD}, which allows commercial and noncommercial use.
\end{itemize}
In ROS, \lstinline[basicstyle=\ttfamily]{roscore} is a service that provides connection information to nodes so that they can transmit messages to and from one another. Each node connects to \lstinline[basicstyle=\ttfamily]{roscore} on startup to register details of the messages it publishes, and the details of the messages to which it wishes to subscribe. \lstinline[basicstyle=\ttfamily]{roscore} is not a server in the traditional client/server sense, all messages are sent peer-to-peer between nodes. The \lstinline[basicstyle=\ttfamily]{roscore} service is only used by nodes to know where to find their peers. Due to this fact, every ROS system needs a running \lstinline[basicstyle=\ttfamily]{roscore}. Upon startup, every ROS node expects its process to have an environment variable \lstinline[basicstyle=\ttfamily]{ROS_MASTER_URI}, containing a string in the format \lstinline[basicstyle=\ttfamily]{http://hostname:portnumber}, to tell it where the \lstinline[basicstyle=\ttfamily]{roscore} service is running, and which port it is accessible on. The connection between nodes, and between individual nodes and \lstinline[basicstyle=\ttfamily]{roscore} is illustrated in figure \ref{fig:roscore}.
\begin{figure}[H]
    \centering
    \includegraphics[width=.4\linewidth]{fig/roscore.png}
    \caption{Roscore and its connection to other nodes in the system.}
    \label{fig:roscore}
\end{figure}
The ephemeral connection between nodes and \lstinline[basicstyle=\ttfamily]{roscore} is illustrated by dashed lines, indicating periodic calls to \lstinline[basicstyle=\ttfamily]{roscore} to find peers, while the peer-to-peer message passing is illustrated by the solid line between the nodes.
The main ROS client libraries are geared towards a UNIX/Linux platform, mainly due to the dependency on large collections of open-source software dependencies \todo{kilde}. Ubuntu Linux is a supported distribution, while others, such as Fedora Linux, Mac OS, and Windows, are designated as experimental and are supported by the community. Due to the simplicity of installation and "out-of-the-box" functionality of ROS on Ubuntu Linux, the most recent long-term supported version of ROS, ROS Kinetic, was installed on a laptop running Ubuntu 16.04 LTS, which was used as a platform for running the various sensor drivers and collecting the data.
\subsubsection{ROS Nodes and Data Flow}
An overview of the implemented sensor driver and data processing nodes is illustrated in figure \ref{fig:ros_nodes}.
\begin{figure}[H]
    \centering
    \includegraphics[width=.8\linewidth]{fig/ros.png}
    \caption{ROS nodes and topic flow.}
    \label{fig:ros_nodes}
\end{figure}
The lidar nodes, camera node and IMU node are all based on open-source ROS packages freely available from the ROS community. The camera driver used is the \lstinline[basicstyle=\ttfamily]{libuvc_camera} driver. This node reads the image stream from the camera over the USB port, providing a ROS interface for cameras meeting the USB Video Class standard \cite{libuvc_camera}. This node publishes messages of the \lstinline[basicstyle=\ttfamily]{sensor_msgs/CompressedImage}-class (among others) native to ROS, where one message correspond to one video frame, with a time stamp corresponding to the arrival time of the image frame over USB. The source code is available at the ROS device drivers repository \cite{ros_drivers}.\\
\vspace{2mm}\\
\noindent The lidar nodes are in the \lstinline[basicstyle=\ttfamily]{velodyne_driver}-package from the ROS device drivers repository \cite{ros_drivers}. This package provides two nodes, the first is \lstinline[basicstyle=\ttfamily]{/velodyne_driver} for collecting all TCP packages sendt over ethernet from the lidar and publishing a message containing the raw data from a full 360-degree scan from the lidar. The message is of the \lstinline[basicstyle=\ttfamily]{velodyne_msgs/VelodyneScan}-class provided in the driver package. The second node, \lstinline[basicstyle=\ttfamily]{/velodyne_cloud}, transforms the raw data into a point cloud given in the frame of reference the user chooses (default \lstinline[basicstyle=\ttfamily]{/velodyne}, the sensor frame) in XYZ-coordinates. In addition to the coordinates of each point, the corresponding intensity of the reflected signal strength and the ring data is published \cite{velodyne_driver}.\\ 
\vspace{2mm}\\
\noindent The point cloud is then published as a message of the \lstinline[basicstyle=\ttfamily]{sensor_msgs/PointCloud2}-class native to ROS. In addition to the coordinates of each point, the corresponding intensity of the reflected signal strength and the ring data is also included in this message \cite{velodyne_driver}.\\
\vspace{2mm}\\
\noindent The driver for the IMU is the \lstinline[basicstyle=\ttfamily]{xsens_driver} package \cite{xsens_driver}, which communicates with the Xsens IMU over USB, and publishes messages containing the measurements from the IMU as a message of the \lstinline[basicstyle=\ttfamily]{sensor_msgs/Imu}-class native to ROS, and GNSS position measurements as a message of the \lstinline[basicstyle=\ttfamily]{sensor_msgs/NavSatFix}-class, also native to ROS \cite{xsens_driver}.\\
\vspace{2mm}\\
\noindent The dummy AIS nodes in figure \ref{fig:ros_nodes} are nodes for receiving and processing GNSS-information received over the internet from a mobile phone, developed at NTNU by the Autosea-project \todo{siter autosea et eller annet}. These nodes are used for receiving and storing the position ground truth for the vessel used in the experiments along with all the other data. They provide raw data as an NMEA-0183 sentence, which is a standard defined by the National Maritime Electronics Association for communication between marine electronics as a \lstinline[basicstyle=\ttfamily]{nmea_msgs/Sentence} message, as well as speed over ground and GNSS position data as \lstinline[basicstyle=\ttfamily]{geometry_msgs/TwistStamped} and \lstinline[basicstyle=\ttfamily]{sensor_msgs/NavSatFix} messages, respectively.
The details of messages passed between nodes in the system is given in table
\begin{tabular}[H]{|c|c|c|c|c|}
	\centering
	\hline
	Topic & Class & Content & Publisher & Subscriber
\end{tabular}
Perhaps not necessary with separate subsections for the drivers. Explain briefly what each node does (perhaps a really brief introduction to ROS).
\subsection{Time Synchronization}
Time delay between camera and imu, Kalibr calibration routine. 
\cleardoublepage